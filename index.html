<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hexagon Terrain Map with Trains</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #1a1a2e;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
      .terrain-key {
        margin-top: 10px;
        font-size: 12px;
      }
      .terrain-item {
        display: flex;
        align-items: center;
        margin: 3px 0;
      }
      .terrain-color {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        border: 1px solid #666;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
      .mode-button {
        background: #444;
        color: white;
        border: 2px solid #666;
        padding: 8px 12px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 13px;
      }
      .mode-button.active {
        background: #ffcc00;
        color: #000;
        border-color: #ffcc00;
      }
      .mode-button:hover {
        background: #555;
      }
      .mode-button.active:hover {
        background: #ffd700;
      }
    </style>
  </head>
  <body>
    <canvas id="hexCanvas"></canvas>
    <div id="info">
      <div>Drag to move | Scroll to zoom | Click edges to place tracks</div>
      <div><strong>Click a tile to debug neighbors in console</strong></div>
      <div>Map tiles: <span id="tileCount">0</span></div>
      <div>Zoom: <span id="zoomLevel">100</span>%</div>
      <div>Tracks placed: <span id="trackCount">0</span></div>
      <div class="terrain-key">
        <div class="terrain-item">
          <div class="terrain-color" style="background: #4a9eff"></div>
          Water
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #f4e4a6"></div>
          Sand
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #7bc950"></div>
          Grass
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #2d5016"></div>
          Forest
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #8b7355"></div>
          Mountain
        </div>
      </div>
    </div>
    <div id="controls">
      <div style="margin-bottom: 8px; font-weight: bold">Mode:</div>
      <button class="mode-button active" data-mode="place">
        üöÇ Place Track
      </button>
      <button class="mode-button" data-mode="remove">‚ùå Remove Track</button>
    </div>

    <script type="module">
      import { draw } from "./draw.js";

      const canvas = document.getElementById("hexCanvas");
      const ctx = canvas.getContext("2d");
      const tileCountEl = document.getElementById("tileCount");
      const zoomLevelEl = document.getElementById("zoomLevel");
      const trackCountEl = document.getElementById("trackCount");

      // Hexagon parameters for FLAT-TOP orientation
      const baseSize = 30;
      let size = baseSize;
      let width = size * 2;
      let height = Math.sqrt(3) * size;

      // Zoom parameters
      let zoom = 1.0;
      const minZoom = 0.3;
      const maxZoom = 3.0;
      const zoomSpeed = 0.1;

      // Interaction state
      let hoveredElement = null;
      let currentMode = "place";

      // Terrain types
      const TERRAIN = {
        WATER: { color: "#4a9eff", name: "Water" },
        SAND: { color: "#f4e4a6", name: "Sand" },
        GRASS: { color: "#7bc950", name: "Grass" },
        FOREST: { color: "#2d5016", name: "Forest" },
        MOUNTAIN: { color: "#8b7355", name: "Mountain" },
      };

      // Object types
      const OBJECT_TYPES = {
        TRACK: "track",
      };

      // Map and objects storage
      const map = {};
      const objects = {};

      // Camera position
      let camera = { x: 0, y: 0 };
      let isDragging = false;
      let dragStartPos = { x: 0, y: 0 };
      let hasDragged = false;
      let lastMousePos = { x: 0, y: 0 };

      // Update size based on zoom
      function updateSizeFromZoom() {
        size = baseSize * zoom;
        width = size * 2;
        height = Math.sqrt(3) * size;
      }

      // Get the neighbor hex for a given side
      function getNeighbor(col, row, side) {
        const isEven = col % 2 === 0;
        const neighbors = isEven
          ? [
              [col + 1, row],
              [col, row + 1],
              [col - 1, row],
              [col - 1, row - 1],
              [col, row - 1],
              [col + 1, row - 1],
            ]
          : [
              [col + 1, row + 1],
              [col, row + 1],
              [col - 1, row + 1],
              [col - 1, row],
              [col, row - 1],
              [col + 1, row],
            ];
        return { col: neighbors[side][0], row: neighbors[side][1] };
      }

      // Get all neighbors for debugging
      function getAllNeighbors(col, row) {
        const neighbors = [];
        const sideNames = [
          "lower-right",
          "bottom",
          "lower-left",
          "upper-left",
          "top",
          "upper-right",
        ];
        for (let side = 0; side < 6; side++) {
          const neighbor = getNeighbor(col, row, side);
          neighbors.push({
            side,
            name: sideNames[side],
            col: neighbor.col,
            row: neighbor.row,
          });
        }
        return neighbors;
      }

      // Create a canonical edge key from two hex coordinates
      function createEdgeKey(col1, row1, col2, row2) {
        const a = [col1, row1];
        const b = [col2, row2];
        const [first, second] = [a, b].sort((p, q) => {
          if (p[0] !== q[0]) return p[0] - q[0];
          return p[1] - q[1];
        });
        return `edge_${first[0]}_${first[1]}_${second[0]}_${second[1]}`;
      }

      // Simple noise-like function for terrain generation
      function pseudoNoise(col, row) {
        let x = col * 0.1;
        let y = row * 0.1;
        return (
          (Math.sin(x * 3.5 + y * 2.1) +
            Math.sin(x * 2.3 - y * 1.7) +
            Math.sin(x * 1.1 + y * 3.3)) /
          3
        );
      }

      // Generate terrain for a hex
      function generateTerrain(col, row) {
        const noise = pseudoNoise(col, row);
        if (noise < -0.5) return TERRAIN.WATER;
        if (noise < -0.2) return TERRAIN.SAND;
        if (noise < 0.3) return TERRAIN.GRASS;
        if (noise < 0.6) return TERRAIN.FOREST;
        return TERRAIN.MOUNTAIN;
      }

      // Get or create hex
      function getHex(col, row) {
        const key = `${col},${row}`;
        if (!map[key]) {
          map[key] = { col, row, terrain: generateTerrain(col, row) };
        }
        return map[key];
      }

      // Convert grid coordinates to pixel coordinates
      function hexToPixel(col, row) {
        const x = col * width * 0.75;
        const y = row * height + ((col % 2) * height) / 2;
        return { x, y };
      }

      // Convert pixel coordinates to grid coordinates
      function pixelToHex(x, y) {
        const q = ((2 / 3) * x) / size;
        const r = ((-1 / 3) * x + (Math.sqrt(3) / 3) * y) / size;

        let cubeQ = q;
        let cubeR = r;
        let cubeS = -q - r;

        let rq = Math.round(cubeQ);
        let rr = Math.round(cubeR);
        let rs = Math.round(cubeS);

        const q_diff = Math.abs(rq - cubeQ);
        const r_diff = Math.abs(rr - cubeR);
        const s_diff = Math.abs(rs - cubeS);

        if (q_diff > r_diff && q_diff > s_diff) {
          rq = -rr - rs;
        } else if (r_diff > s_diff) {
          rr = -rq - rs;
        }

        const col = rq;
        const row = rr + (rq - (rq & 1)) / 2;

        return { col, row };
      }

      // Get the 6 vertices of a hex in pixel coordinates
      function getHexVertices(centerX, centerY) {
        const angles = [0, 60, 120, 180, 240, 300];
        return angles.map((angle) => {
          const angleRad = (Math.PI / 180) * angle;
          return {
            x: centerX + size * Math.cos(angleRad),
            y: centerY + size * Math.sin(angleRad),
          };
        });
      }

      // Distance between two points
      function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }

      // Distance to line segment
      function distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared === 0) {
          return distance(px, py, x1, y1);
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const closestX = x1 + t * dx;
        const closestY = y1 + t * dy;

        return distance(px, py, closestX, closestY);
      }

      // Find what the mouse is hovering over
      function findHoveredElement(mouseX, mouseY) {
        const worldX = mouseX - camera.x;
        const worldY = mouseY - camera.y;

        const hexCoord = pixelToHex(worldX, worldY);
        const hexPos = hexToPixel(hexCoord.col, hexCoord.row);

        const vertices = getHexVertices(hexPos.x, hexPos.y);
        const vertexRadius = 8 * zoom;

        for (let i = 0; i < vertices.length; i++) {
          const v = vertices[i];
          if (distance(worldX, worldY, v.x, v.y) < vertexRadius) {
            return {
              type: "vertex",
              col: hexCoord.col,
              row: hexCoord.row,
              vertexIndex: i,
              x: v.x,
              y: v.y,
            };
          }
        }

        const edgeRadius = 12 * zoom;

        for (let i = 0; i < 6; i++) {
          const v1 = vertices[i];
          const v2 = vertices[(i + 1) % 6];

          const dist = distanceToLineSegment(
            worldX,
            worldY,
            v1.x,
            v1.y,
            v2.x,
            v2.y
          );

          if (dist < edgeRadius) {
            const neighbor = getNeighbor(hexCoord.col, hexCoord.row, i);

            return {
              type: "edge",
              col: hexCoord.col,
              row: hexCoord.row,
              edgeIndex: i,
              side: i,
              x: (v1.x + v2.x) / 2,
              y: (v1.y + v2.y) / 2,
              edgeKey: createEdgeKey(
                hexCoord.col,
                hexCoord.row,
                neighbor.col,
                neighbor.row
              ),
            };
          }
        }

        if (distance(worldX, worldY, hexPos.x, hexPos.y) < size) {
          return {
            type: "tile",
            col: hexCoord.col,
            row: hexCoord.row,
            x: hexPos.x,
            y: hexPos.y,
          };
        }

        return null;
      }

      // Get visible hex range
      function getVisibleHexRange() {
        const margin = 3;
        const topLeft = pixelToHex(
          -camera.x - width * margin,
          -camera.y - height * margin
        );
        const bottomRight = pixelToHex(
          -camera.x + canvas.width + width * margin,
          -camera.y + canvas.height + height * margin
        );

        return {
          minCol: topLeft.col - margin,
          maxCol: bottomRight.col + margin,
          minRow: topLeft.row - margin,
          maxRow: bottomRight.row + margin,
        };
      }

      // Initialize visible map
      function initializeVisibleMap() {
        const range = getVisibleHexRange();
        for (let col = range.minCol; col <= range.maxCol; col++) {
          for (let row = range.minRow; row <= range.maxRow; row++) {
            getHex(col, row);
          }
        }
      }

      // Build draw params object
      function getDrawParams() {
        return {
          canvas,
          map,
          objects,
          camera,
          hoveredElement,
          size,
          zoom,
          TERRAIN,
          OBJECT_TYPES,
          tileCountEl,
          zoomLevelEl,
          trackCountEl,
        };
      }

      // Handle element clicked event
      function handleClick(element) {
        if (!element) return;

        if (element.type === "tile") {
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
          console.log("üîç TILE DEBUG INFO");
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
          console.log(`Clicked Tile: (${element.col}, ${element.row})`);
          console.log(`Column is ${element.col % 2 === 0 ? "EVEN" : "ODD"}`);
          console.log("\nAll Neighbors (in order):");

          const neighbors = getAllNeighbors(element.col, element.row);
          neighbors.forEach((n) => {
            console.log(`  Side ${n.side} (${n.name}): (${n.col}, ${n.row})`);
          });

          console.log("\nVertex angles (for reference):");
          console.log("  Vertex 0: 0¬∞ (right)");
          console.log("  Vertex 1: 60¬∞ (lower-right)");
          console.log("  Vertex 2: 120¬∞ (lower-left)");
          console.log("  Vertex 3: 180¬∞ (left)");
          console.log("  Vertex 4: 240¬∞ (upper-left)");
          console.log("  Vertex 5: 300¬∞ (upper-right)");

          console.log("\nEdge mappings:");
          console.log("  Edge 0: between vertices 0-1 (right edge)");
          console.log("  Edge 1: between vertices 1-2 (lower-right edge)");
          console.log("  Edge 2: between vertices 2-3 (lower-left edge)");
          console.log("  Edge 3: between vertices 3-4 (left edge)");
          console.log("  Edge 4: between vertices 4-5 (upper-left edge)");
          console.log("  Edge 5: between vertices 5-0 (upper-right edge)");
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");

          return;
        }

        if (element.type === "edge") {
          const edgeKey = element.edgeKey;

          if (currentMode === "place") {
            if (!objects[edgeKey]) {
              const neighbor = getNeighbor(
                element.col,
                element.row,
                element.side
              );
              objects[edgeKey] = {
                type: OBJECT_TYPES.TRACK,
                hex1: { col: element.col, row: element.row },
                hex2: { col: neighbor.col, row: neighbor.row },
                placedAt: Date.now(),
              };
              console.log("üöÇ TRACK PLACED", {
                edgeKey,
                hex1: `(${element.col}, ${element.row})`,
                hex2: `(${neighbor.col}, ${neighbor.row})`,
              });
              draw(ctx, getDrawParams());
            }
          } else if (currentMode === "remove") {
            if (objects[edgeKey]) {
              delete objects[edgeKey];
              console.log("üóëÔ∏è TRACK REMOVED", { edgeKey });
              draw(ctx, getDrawParams());
            }
          }
        }
      }

      // Resize canvas to fill window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initializeVisibleMap();
        draw(ctx, getDrawParams());
      }

      // Handle zoom
      function handleZoom(delta, mouseX, mouseY) {
        const oldZoom = zoom;

        const zoomChange = delta > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
        zoom *= zoomChange;
        zoom = Math.max(minZoom, Math.min(maxZoom, zoom));

        if (oldZoom === zoom) return;

        const worldX = mouseX - camera.x;
        const worldY = mouseY - camera.y;

        updateSizeFromZoom();

        camera.x = mouseX - worldX * (zoom / oldZoom);
        camera.y = mouseY - worldY * (zoom / oldZoom);

        initializeVisibleMap();
        draw(ctx, getDrawParams());
      }

      // Mode button handlers
      document.querySelectorAll(".mode-button").forEach((button) => {
        button.addEventListener("click", () => {
          document
            .querySelectorAll(".mode-button")
            .forEach((b) => b.classList.remove("active"));
          button.classList.add("active");
          currentMode = button.dataset.mode;
        });
      });

      // Mouse event handlers
      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        hasDragged = false;
        dragStartPos = { x: e.clientX, y: e.clientY };
        lastMousePos = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;

          if (
            Math.abs(e.clientX - dragStartPos.x) > 3 ||
            Math.abs(e.clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          camera.x += dx;
          camera.y += dy;
          lastMousePos = { x: e.clientX, y: e.clientY };
          initializeVisibleMap();
          draw(ctx, getDrawParams());
        } else {
          const newHovered = findHoveredElement(e.clientX, e.clientY);

          if (JSON.stringify(newHovered) !== JSON.stringify(hoveredElement)) {
            hoveredElement = newHovered;
            draw(ctx, getDrawParams());
          }
        }
      });

      canvas.addEventListener("click", (e) => {
        if (!hasDragged) {
          const clicked = findHoveredElement(e.clientX, e.clientY);
          handleClick(clicked);
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
        if (hoveredElement) {
          hoveredElement = null;
          draw(ctx, getDrawParams());
        }
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          handleZoom(-e.deltaY, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // Touch support
      let lastTouchDistance = null;

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (e.touches.length === 2) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        } else {
          isDragging = true;
          hasDragged = false;
          dragStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 2 && lastTouchDistance) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

          const delta = distance - lastTouchDistance;
          handleZoom(delta * 2, centerX, centerY);

          lastTouchDistance = distance;
        } else if (e.touches.length === 1 && isDragging) {
          const dx = e.touches[0].clientX - lastMousePos.x;
          const dy = e.touches[0].clientY - lastMousePos.y;

          if (
            Math.abs(e.touches[0].clientX - dragStartPos.x) > 3 ||
            Math.abs(e.touches[0].clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          camera.x += dx;
          camera.y += dy;
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          initializeVisibleMap();
          draw(ctx, getDrawParams());
        }
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();

        if (!hasDragged && e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          const clicked = findHoveredElement(touch.clientX, touch.clientY);
          handleClick(clicked);
        }

        isDragging = false;
        lastTouchDistance = null;
      });

      // Initialize
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
    </script>
  </body>
</html>
