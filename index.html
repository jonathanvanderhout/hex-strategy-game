<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Hexagon Terrain Map with Trains</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #1a1a2e;
        font-family: Arial, sans-serif;
      }
      canvas {
        display: block;
        cursor: grab;
      }
      canvas:active {
        cursor: grabbing;
      }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
      .terrain-key {
        margin-top: 10px;
        font-size: 12px;
      }
      .terrain-item {
        display: flex;
        align-items: center;
        margin: 3px 0;
      }
      .terrain-color {
        width: 20px;
        height: 20px;
        margin-right: 8px;
        border: 1px solid #666;
      }
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-size: 14px;
      }
      .mode-button {
        background: #444;
        color: white;
        border: 2px solid #666;
        padding: 8px 12px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        font-size: 13px;
      }
      .mode-button.active {
        background: #ffcc00;
        color: #000;
        border-color: #ffcc00;
      }
      .mode-button:hover {
        background: #555;
      }
      .mode-button.active:hover {
        background: #ffd700;
      }
    </style>
  </head>
  <body>
    <canvas id="hexCanvas"></canvas>
    <div id="info">
      <div>Drag to move | Scroll to zoom | Click edges to place tracks</div>
      <div><strong>Click a tile to debug neighbors in console</strong></div>
      <div>Map tiles: <span id="tileCount">0</span></div>
      <div>Zoom: <span id="zoomLevel">100</span>%</div>
      <div>Tracks placed: <span id="trackCount">0</span></div>
      <div>Trains: <span id="trainCount">0</span></div>
      <div class="terrain-key">
        <div class="terrain-item">
          <div class="terrain-color" style="background: #4a9eff"></div>
          Water
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #f4e4a6"></div>
          Sand
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #7bc950"></div>
          Grass
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #2d5016"></div>
          Forest
        </div>
        <div class="terrain-item">
          <div class="terrain-color" style="background: #8b7355"></div>
          Mountain
        </div>
      </div>
    </div>
    <div id="controls">
      <div style="margin-bottom: 8px; font-weight: bold">Mode:</div>
      <button class="mode-button active" data-mode="place">
        üöÇ Place Track
      </button>
      <button class="mode-button" data-mode="remove">‚ùå Remove Track</button>
      <button class="mode-button" data-mode="train">üöÜ Place Train</button>
      <button class="mode-button" data-mode="building">
        üè¢ Place Building
      </button>
    </div>

    <script type="module">
      import { draw } from "./draw.js";
      import { generateTerrain, getConfig, updateConfig} from "./terrainGeneration.js";
      import {
        hexToPixel,
        pixelToHex,
        getHexVertices,
        getNeighbor,
      } from "./hexUtils.js";
     import { SaveGameManager, createSaveLoadButton } from './savegame.js';


      const canvas = document.getElementById("hexCanvas");
      const ctx = canvas.getContext("2d");
      const tileCountEl = document.getElementById("tileCount");
      const zoomLevelEl = document.getElementById("zoomLevel");
      const trackCountEl = document.getElementById("trackCount");
      const trainCountEl = document.getElementById("trainCount");

      // Hexagon parameters for FLAT-TOP orientation
      const baseSize = 30;
      let size = baseSize;
      let width = size * 2;
      let height = Math.sqrt(3) * size;

      // Zoom parameters
      let zoom = 1.0;
      const minZoom = 0.3;
      const maxZoom = 3.0;
      const zoomSpeed = 0.1;

      // Interaction state
      let hoveredElement = null;
      let currentMode = "place";

      // Terrain types
      const TERRAIN = {
        WATER: { color: "#4a9eff", name: "Water" },
        SAND: { color: "#f4e4a6", name: "Sand" },
        GRASS: { color: "#7bc950", name: "Grass" },
        FOREST: { color: "#2d5016", name: "Forest" },
        MOUNTAIN: { color: "#8b7355", name: "Mountain" },
      };

      // Object types
      const OBJECT_TYPES = {
        TRACK: "track",
        TRAIN: "train",
        BUILDING: "building",
      };

      // Map and objects storage
      // const placed_buildings = {};
      // const trains = [];
      // let nextTrainId = 1;

      // Track network graph - maps vertex keys to connected edges
      const trackGraph = {};

      // Camera position
      // let camera = { x: 0, y: 0 };
      let isDragging = false;
      let dragStartPos = { x: 0, y: 0 };
      let hasDragged = false;
      let lastMousePos = { x: 0, y: 0 };

      const gameState = {
        placed_tracks: {},
        placed_buildings: {},
        trains: [],
        nextTrainId: 1,
        camera: { x: 0, y: 0 },
        terrainConfig: getConfig()
      };
      const map = {} // not saved because it can just be regenerated. 

      // Update size based on zoom
      function updateSizeFromZoom() {
        size = baseSize * zoom;
        width = size * 2;
        height = Math.sqrt(3) * size;
      }

      // Get all neighbors for debugging
      function getAllNeighbors(col, row) {
        const neighbors = [];
        const sideNames = [
          "lower-right",
          "bottom",
          "lower-left",
          "upper-left",
          "top",
          "upper-right",
        ];
        for (let side = 0; side < 6; side++) {
          const neighbor = getNeighbor(col, row, side);
          neighbors.push({
            side,
            name: sideNames[side],
            col: neighbor.col,
            row: neighbor.row,
          });
        }
        return neighbors;
      }

      // Create a canonical edge key from two hex coordinates
      function createEdgeKey(col1, row1, col2, row2) {
        const a = [col1, row1];
        const b = [col2, row2];
        const [first, second] = [a, b].sort((p, q) => {
          if (p[0] !== q[0]) return p[0] - q[0];
          return p[1] - q[1];
        });
        return `edge_${first[0]}_${first[1]}_${second[0]}_${second[1]}`;
      }

      // Create a vertex key from hex coordinates and vertex index
      function createVertexKey(col, row, vertexIndex) {
        // Use baseSize instead of size to make vertex keys zoom-independent
        const pos = hexToPixel(col, row, size);
        const angles = [0, 60, 120, 180, 240, 300];
        const angleRad = (Math.PI / 180) * angles[vertexIndex];
        // Use baseSize here instead of size - this makes the key independent of zoom
        const x =
          Math.round(
            ((pos.x / size) * baseSize + baseSize * Math.cos(angleRad)) * 100
          ) / 100;
        const y =
          Math.round(
            ((pos.y / size) * baseSize + baseSize * Math.sin(angleRad)) * 100
          ) / 100;
        return `vertex_${x}_${y}`;
      }

      // Get the two vertices for an edge
      function getEdgeVertices(col, row, side) {
        const vertex1Index = side;
        const vertex2Index = (side + 1) % 6;
        return [
          createVertexKey(col, row, vertex1Index),
          createVertexKey(col, row, vertex2Index),
        ];
      }

      // Build track network graph
      function rebuildTrackGraph() {
        // Clear existing graph
        for (let key in trackGraph) {
          delete trackGraph[key];
        }

        // Build graph from all track objects
        for (let edgeKey in gameState.placed_tracks) {
          const obj = gameState.placed_tracks[edgeKey];
          if (obj.type === OBJECT_TYPES.TRACK) {
            // Find which side this edge is on hex1
            let side = -1;
            for (let i = 0; i < 6; i++) {
              const neighbor = getNeighbor(obj.hex1.col, obj.hex1.row, i);
              if (
                neighbor.col === obj.hex2.col &&
                neighbor.row === obj.hex2.row
              ) {
                side = i;
                break;
              }
            }

            if (side !== -1) {
              const [vertex1Key, vertex2Key] = getEdgeVertices(
                obj.hex1.col,
                obj.hex1.row,
                side
              );

              // Add this edge to both vertices' connection lists
              if (!trackGraph[vertex1Key]) trackGraph[vertex1Key] = [];
              if (!trackGraph[vertex2Key]) trackGraph[vertex2Key] = [];

              trackGraph[vertex1Key].push(edgeKey);
              trackGraph[vertex2Key].push(edgeKey);
            }
          }
        }
      }

      // Get connected tracks at a vertex, excluding the current track
      function getConnectedTracks(currentEdgeKey, vertexKey) {
        if (!trackGraph[vertexKey]) return [];
        return trackGraph[vertexKey].filter((key) => key !== currentEdgeKey);
      }

      // Find which vertex the train is at based on its progress
      function getTrainVertex(train) {
        // Find which side this edge is on hex1
        let side = -1;
        for (let i = 0; i < 6; i++) {
          const neighbor = getNeighbor(train.hex1.col, train.hex1.row, i);
          if (
            neighbor.col === train.hex2.col &&
            neighbor.row === train.hex2.row
          ) {
            side = i;
            break;
          }
        }

        if (side === -1) return null;

        const [vertex1Key, vertex2Key] = getEdgeVertices(
          train.hex1.col,
          train.hex1.row,
          side
        );

        // If progress is 0, train is at vertex1; if 1, train is at vertex2
        return train.progress <= 0 ? vertex1Key : vertex2Key;
      }

      // Transition train to a new track segment
      function transitionTrainToNewTrack(train, newEdgeKey) {
        const newTrack = gameState.placed_tracks[newEdgeKey];
        if (!newTrack) return false;

        // Get current vertex the train is at
        const currentVertex = getTrainVertex(train);
        if (!currentVertex) return false;

        // Find which side of newTrack's hex1 this edge is on
        let newSide = -1;
        for (let i = 0; i < 6; i++) {
          const neighbor = getNeighbor(newTrack.hex1.col, newTrack.hex1.row, i);
          if (
            neighbor.col === newTrack.hex2.col &&
            neighbor.row === newTrack.hex2.row
          ) {
            newSide = i;
            break;
          }
        }

        if (newSide === -1) return false;

        const [newVertex1, newVertex2] = getEdgeVertices(
          newTrack.hex1.col,
          newTrack.hex1.row,
          newSide
        );

        // Determine which end of the new track to start from
        if (currentVertex === newVertex1) {
          // Start from vertex1 (progress 0) and go toward vertex2
          train.hex1 = newTrack.hex1;
          train.hex2 = newTrack.hex2;
          train.edgeKey = newEdgeKey;
          train.progress = 0;
          train.direction = 1;
        } else if (currentVertex === newVertex2) {
          // Start from vertex2 (progress 1) and go toward vertex1
          train.hex1 = newTrack.hex1;
          train.hex2 = newTrack.hex2;
          train.edgeKey = newEdgeKey;
          train.progress = 1;
          train.direction = -1;
        } else {
          return false;
        }

        return true;
      }

      // Get or create hex
      function getHex(col, row) {
        const key = `${col},${row}`;
        if (!map[key]) {
          map[key] = { col, row, terrain: generateTerrain(col, row, TERRAIN) };
        }
        return map[key];
      }

      // Distance between two points
      function distance(x1, y1, x2, y2) {
        return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
      }

      // Distance to line segment
      function distanceToLineSegment(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lengthSquared = dx * dx + dy * dy;

        if (lengthSquared === 0) {
          return distance(px, py, x1, y1);
        }

        let t = ((px - x1) * dx + (py - y1) * dy) / lengthSquared;
        t = Math.max(0, Math.min(1, t));

        const closestX = x1 + t * dx;
        const closestY = y1 + t * dy;

        return distance(px, py, closestX, closestY);
      }

      // Find what the mouse is hovering over
      function findHoveredElement(mouseX, mouseY) {
        const worldX = mouseX - gameState.camera.x;
        const worldY = mouseY - gameState.camera.y;

        const hexCoord = pixelToHex(worldX, worldY, size);
        const hexPos = hexToPixel(hexCoord.col, hexCoord.row, size);

        const vertices = getHexVertices(hexPos.x, hexPos.y, size);
        const vertexRadius = 8 * zoom;

        for (let i = 0; i < vertices.length; i++) {
          const v = vertices[i];
          if (distance(worldX, worldY, v.x, v.y) < vertexRadius) {
            return {
              type: "vertex",
              col: hexCoord.col,
              row: hexCoord.row,
              vertexIndex: i,
              x: v.x,
              y: v.y,
            };
          }
        }

        const edgeRadius = 12 * zoom;

        for (let i = 0; i < 6; i++) {
          const v1 = vertices[i];
          const v2 = vertices[(i + 1) % 6];

          const dist = distanceToLineSegment(
            worldX,
            worldY,
            v1.x,
            v1.y,
            v2.x,
            v2.y
          );

          if (dist < edgeRadius) {
            const neighbor = getNeighbor(hexCoord.col, hexCoord.row, i);

            return {
              type: "edge",
              col: hexCoord.col,
              row: hexCoord.row,
              edgeIndex: i,
              side: i,
              x: (v1.x + v2.x) / 2,
              y: (v1.y + v2.y) / 2,
              edgeKey: createEdgeKey(
                hexCoord.col,
                hexCoord.row,
                neighbor.col,
                neighbor.row
              ),
            };
          }
        }

        if (distance(worldX, worldY, hexPos.x, hexPos.y) < size) {
          return {
            type: "tile",
            col: hexCoord.col,
            row: hexCoord.row,
            x: hexPos.x,
            y: hexPos.y,
          };
        }

        return null;
      }

      // Get visible hex range
      function getVisibleHexRange() {
        const margin = 3;
        const topLeft = pixelToHex(
          -gameState.camera.x - width * margin,
          -gameState.camera.y - height * margin,
          size
        );
        const bottomRight = pixelToHex(
          -gameState.camera.x + canvas.width + width * margin,
          -gameState.camera.y + canvas.height + height * margin,
          size
        );

        return {
          minCol: topLeft.col - margin,
          maxCol: bottomRight.col + margin,
          minRow: topLeft.row - margin,
          maxRow: bottomRight.row + margin,
        };
      }

      // Initialize visible map
      function initializeVisibleMap() {
        const range = getVisibleHexRange();
        for (let col = range.minCol; col <= range.maxCol; col++) {
          for (let row = range.minRow; row <= range.maxRow; row++) {
            getHex(col, row);
          }
        }
      }

      // Build draw params object
      function getDrawParams() {
        return {
          canvas,
          map:map,
          placed_tracks: gameState.placed_tracks,
          placed_buildings:gameState.placed_buildings,
          trains:gameState.trains,
          camera:gameState.camera,
          hoveredElement,
          size,
          zoom,
          TERRAIN,
          OBJECT_TYPES,
          tileCountEl,
          zoomLevelEl,
          trackCountEl,
          trainCountEl,
        };
      }

      // Handle element clicked event
      function handleClick(element) {
        if (!element) return;

        if (element.type === "tile") {
          // Building placement
          if (currentMode === "building") {
            const tileKey = `${element.col},${element.row}`;
            if (!gameState.placed_buildings[tileKey]) {
              gameState.placed_buildings[tileKey] = {
                type: OBJECT_TYPES.BUILDING,
                col: element.col,
                row: element.row,
                placedAt: Date.now(),
              };
              console.log("üè¢ BUILDING PLACED", {
                tileKey,
                col: element.col,
                row: element.row,
              });
            }
            return;
          }

          // Debug info
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
          console.log("üîç TILE DEBUG INFO");
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
          console.log(`Clicked Tile: (${element.col}, ${element.row})`);
          console.log(`Column is ${element.col % 2 === 0 ? "EVEN" : "ODD"}`);
          console.log("\nAll Neighbors (in order):");

          const neighbors = getAllNeighbors(element.col, element.row);
          neighbors.forEach((n) => {
            console.log(`  Side ${n.side} (${n.name}): (${n.col}, ${n.row})`);
          });

          console.log("\nVertex angles (for reference):");
          console.log("  Vertex 0: 0¬∞ (right)");
          console.log("  Vertex 1: 60¬∞ (lower-right)");
          console.log("  Vertex 2: 120¬∞ (lower-left)");
          console.log("  Vertex 3: 180¬∞ (left)");
          console.log("  Vertex 4: 240¬∞ (upper-left)");
          console.log("  Vertex 5: 300¬∞ (upper-right)");

          console.log("\nEdge mappings:");
          console.log("  Edge 0: between vertices 0-1 (right edge)");
          console.log("  Edge 1: between vertices 1-2 (lower-right edge)");
          console.log("  Edge 2: between vertices 2-3 (lower-left edge)");
          console.log("  Edge 3: between vertices 3-4 (left edge)");
          console.log("  Edge 4: between vertices 4-5 (upper-left edge)");
          console.log("  Edge 5: between vertices 5-0 (upper-right edge)");
          console.log("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");

          return;
        }

        if (element.type === "edge") {
          const edgeKey = element.edgeKey;

          if (currentMode === "place") {
            if (!gameState.placed_tracks[edgeKey]) {
              const neighbor = getNeighbor(
                element.col,
                element.row,
                element.side
              );
              gameState.placed_tracks[edgeKey] = {
                type: OBJECT_TYPES.TRACK,
                hex1: { col: element.col, row: element.row },
                hex2: { col: neighbor.col, row: neighbor.row },
                placedAt: Date.now(),
              };
              console.log("üöÇ TRACK PLACED", {
                edgeKey,
                hex1: `(${element.col}, ${element.row})`,
                hex2: `(${neighbor.col}, ${neighbor.row})`,
              });
              rebuildTrackGraph();
            }
          } else if (currentMode === "remove") {
            if (gameState.placed_tracks[edgeKey]) {
              delete gameState.placed_tracks[edgeKey];
              console.log("üóëÔ∏è TRACK REMOVED", { edgeKey });
              rebuildTrackGraph();
            }
          } else if (currentMode === "train") {
            if (gameState.placed_tracks[edgeKey]) {
              const neighbor = getNeighbor(
                element.col,
                element.row,
                element.side
              );
              gameState.trains.push({
                id: gameState.nextTrainId++,
                edgeKey: edgeKey,
                hex1: { col: element.col, row: element.row },
                hex2: { col: neighbor.col, row: neighbor.row },
                progress: 0.5,
                direction: 1,
                speed: 0.02,
              });
              console.log("üöÜ TRAIN PLACED", {
                id: gameState.nextTrainId - 1,
                edgeKey,
                hex1: `(${element.col}, ${element.row})`,
                hex2: `(${neighbor.col}, ${neighbor.row})`,
              });
            }
          }
        }
      }

      // Animate trains
      function animateTrains() {
        gameState.trains.forEach((train) => {
          train.progress += train.speed * train.direction;

          // Check if train reached the end of the track
          if (train.progress >= 1 || train.progress <= 0) {
            // Clamp progress
            train.progress = train.progress >= 1 ? 1 : 0;

            // Get current vertex
            const currentVertex = getTrainVertex(train);

            if (currentVertex) {
              // Get connected tracks at this vertex
              const connectedTracks = getConnectedTracks(
                train.edgeKey,
                currentVertex
              );

              if (connectedTracks.length > 0) {
                // Random walk: pick a random connected track
                const nextTrackKey =
                  connectedTracks[
                    Math.floor(Math.random() * connectedTracks.length)
                  ];

                // Transition to the new track
                const transitioned = transitionTrainToNewTrack(
                  train,
                  nextTrackKey
                );

                if (!transitioned) {
                  // If transition failed, just reverse direction
                  train.direction *= -1;
                }
              } else {
                // Dead end - reverse direction
                train.direction *= -1;
              }
            } else {
              // Fallback: reverse direction
              train.direction *= -1;
            }
          }
        });

        draw(ctx, getDrawParams());
        requestAnimationFrame(animateTrains);
      }

      // Resize canvas to fill window
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initializeVisibleMap();
      }

      // Handle zoom
      function handleZoom(delta, mouseX, mouseY) {
        const oldZoom = zoom;

        const zoomChange = delta > 0 ? 1 + zoomSpeed : 1 - zoomSpeed;
        zoom *= zoomChange;
        zoom = Math.max(minZoom, Math.min(maxZoom, zoom));

        if (oldZoom === zoom) return;

        const worldX = mouseX - gameState.camera.x;
        const worldY = mouseY - gameState.camera.y;

        updateSizeFromZoom();

        gameState.camera.x = mouseX - worldX * (zoom / oldZoom);
        gameState.camera.y = mouseY - worldY * (zoom / oldZoom);

        initializeVisibleMap();
      }
      // Save/Load system
      const saveGameManager = new SaveGameManager(gameState);
      window.saveGameManager = saveGameManager;

      const saveLoadBtn = createSaveLoadButton();
      document.body.appendChild(saveLoadBtn);
      saveLoadBtn.addEventListener('click', () => saveGameManager.show());

      // Handle loading games
      window.addEventListener('loadGame', (e) => {
        const state = e.detail;
        
        // Clear existing state
        for (let key in gameState.placed_tracks) delete gameState.placed_tracks[key];
        for (let key in gameState.placed_buildings) delete gameState.placed_buildings[key];
        gameState.trains.length = 0;
        
        // Restore terrain config first
        updateConfig(state.terrainConfig);
        gameState.terrainConfig = state.terrainConfig;
        
        // Restore game state
        Object.assign(gameState.placed_tracks, state.placed_tracks);
        Object.assign(gameState.placed_buildings, state.placed_buildings);
        gameState.trains.push(...state.trains);
        gameState.nextTrainId = state.nextTrainId;
        gameState.camera = { ...state.camera };
        
        // Rebuild derived data
        rebuildTrackGraph();
        
        // Clear and regenerate map with new terrain config
        for (let key in map) delete map[key];
        initializeVisibleMap();
        
        console.log('‚úÖ Game loaded successfully!');
      });

      // Mode button handlers
      document.querySelectorAll(".mode-button").forEach((button) => {
        button.addEventListener("click", () => {
          document
            .querySelectorAll(".mode-button")
            .forEach((b) => b.classList.remove("active"));
          button.classList.add("active");
          currentMode = button.dataset.mode;
        });
      });

      // Mouse event handlers
      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        hasDragged = false;
        dragStartPos = { x: e.clientX, y: e.clientY };
        lastMousePos = { x: e.clientX, y: e.clientY };
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const dx = e.clientX - lastMousePos.x;
          const dy = e.clientY - lastMousePos.y;

          if (
            Math.abs(e.clientX - dragStartPos.x) > 3 ||
            Math.abs(e.clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          gameState.camera.x += dx;
          gameState.camera.y += dy;
          lastMousePos = { x: e.clientX, y: e.clientY };
          initializeVisibleMap();
        } else {
          const newHovered = findHoveredElement(e.clientX, e.clientY);

          if (JSON.stringify(newHovered) !== JSON.stringify(hoveredElement)) {
            hoveredElement = newHovered;
          }
        }
      });

      canvas.addEventListener("click", (e) => {
        if (!hasDragged) {
          const clicked = findHoveredElement(e.clientX, e.clientY);
          handleClick(clicked);
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });

      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
        if (hoveredElement) {
          hoveredElement = null;
        }
      });

      window.addEventListener("terrainRegenerate", () => {
        console.log("üîÑ Regenerating world...");

        // Clear the existing map completely
        for (let key in map) {
          delete map[key];
        }

        // Reinitialize visible map with new terrain
        initializeVisibleMap();

        console.log("‚úÖ World regenerated!");
      });

      canvas.addEventListener(
        "wheel",
        (e) => {
          e.preventDefault();
          handleZoom(-e.deltaY, e.clientX, e.clientY);
        },
        { passive: false }
      );

      // Touch support
      let lastTouchDistance = null;

      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();

        if (e.touches.length === 2) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
        } else {
          isDragging = true;
          hasDragged = false;
          dragStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();

        if (e.touches.length === 2 && lastTouchDistance) {
          const dx = e.touches[1].clientX - e.touches[0].clientX;
          const dy = e.touches[1].clientY - e.touches[0].clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
          const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;

          const delta = distance - lastTouchDistance;
          handleZoom(delta * 2, centerX, centerY);

          lastTouchDistance = distance;
        } else if (e.touches.length === 1 && isDragging) {
          const dx = e.touches[0].clientX - lastMousePos.x;
          const dy = e.touches[0].clientY - lastMousePos.y;

          if (
            Math.abs(e.touches[0].clientX - dragStartPos.x) > 3 ||
            Math.abs(e.touches[0].clientY - dragStartPos.y) > 3
          ) {
            hasDragged = true;
          }

          gameState.camera.x += dx;
          gameState.camera.y += dy;
          lastMousePos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
          initializeVisibleMap();
        }
      });

      canvas.addEventListener("touchend", (e) => {
        e.preventDefault();

        if (!hasDragged && e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          const clicked = findHoveredElement(touch.clientX, touch.clientY);
          handleClick(clicked);
        }

        isDragging = false;
        lastTouchDistance = null;
      });

      // Initialize
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();
      animateTrains();
    </script>
  </body>
</html>
